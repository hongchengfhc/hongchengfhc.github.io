<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gridea</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-siteapp"/>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/mdui/0.4.3/css/mdui.min.css">
    <link rel="stylesheet" href="media/css/post.css">
    <link rel="stylesheet" href="media/live2d/css/live2d.css" />
    
</head>
<body class=" mdui-appbar-with-toolbar  mdui-theme-primary-pink mdui-theme-accent-pink">
<header class="mdui-toolbar mdui-color-pink mdui-appbar-fixed mdui-appbar-scroll-toolbar-hide" style="z-index: 1000">
    <a href="javascript:;" mdui-drawer="{target: '#left-drawer',overlay:true}" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
    <span class="mdui-typo-title">Gridea</span>
    <div class="mdui-toolbar-spacer"></div>
<!--    <a href="javascript:history.go(0);" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
    <a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">more_vert</i></a>
</header>

<div class="mdui-drawer mdui-color-white mdui-drawer-full-height mdui-drawer-close" id="left-drawer">
    <ul class="mdui-list">
        <li class="mdui-subheader">菜单</li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/" class="mdui-list-item-content">首页</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/archives" class="mdui-list-item-content">归档</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/tags" class="mdui-list-item-content">标签</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/post/about" class="mdui-list-item-content">关于</a>
        </li>
        
    </ul>
</div>

<div id="content" class="site-content">
    <div id="primary" class="content-area">
        <main id="main" class="site-main" role="main">
            <article id="post-1270" class="post-1270 post type-post status-publish format-standard hentry category-90 category-129 tag-149">
                <header class="entry-header">
                    <h1 class="entry-title">进阶1-02-01 ESMAScript 新特性</h1>
                    <p class="entry-census">发布于 2021-03-26</p>
                    <hr>
                </header>
                <div class="neko">
                    <h1 id="esmascript-新特性">ESMAScript 新特性</h1>
<h2 id="1-ecmascript-概述">1. ECMAScript 概述</h2>
<h3 id="web环境">@Web环境</h3>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/653Zc9"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/195cf00ad60f40e6a5949af4e5634643~tplv-k3u1fbpfcp-zoom-1.image" alt="653Zc9.png" loading="lazy"></a></figure>
<h3 id="nodejs">@Node.js</h3>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/653K76"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00315f7faf01474fb049ea4e92b2e297~tplv-k3u1fbpfcp-zoom-1.image" alt="653K76.png" loading="lazy"></a></figure>
<h3 id="ecmascript-版本">ECMAScript 版本</h3>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/6531hD"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c999f48b428740f4ba33289c9628f4ab~tplv-k3u1fbpfcp-zoom-1.image" alt="6531hD.png" loading="lazy"></a></figure>
<h2 id="2-es2015-let-与块级作用域以及const">2. ES2015 let 与块级作用域，以及const</h2>
<h4 id="let">let</h4>
<pre><code class="language-js">使用var 导致变量提升
console.log(foo); // undefine;
var foo = 'zce';
// 官方的bug不叫bug，叫特性
</code></pre>
<pre><code class="language-js">console.log(foo);
let foo = 'zce';
</code></pre>
<h4 id="const-恒量常量">const 恒量/常量</h4>
<blockquote>
<p>在let的基础上增加了只读属性，声明过后不允许再被修改</p>
</blockquote>
<ul>
<li><code>const</code> 它所声明的成员不能被修改，只是说我们不允许在声明了过后重新去指向一个新的内存地址，并不是说我们不允许修改恒量中的属性成员</li>
</ul>
<pre><code class="language-js">// 不允许以下情况
const name = 'zce';
name = 'jack';

const name;
name = 'zce';

// 下面的代码是允许的
const obj = {};
obj.name = 'zce' 

// 下面是不允许的
const obj = {};
obj = {};

</code></pre>
<h2 id="3-es2015-模板字符串">3. ES2015 模板字符串</h2>
<h4 id="模板字符串字面量-template-literals">模板字符串字面量 Template literals</h4>
<pre><code class="language-js">const str = `hello es2015, this is a string`
console.log(str)

// 支持多行
const str = `hello es2015, 

this is a string`
console.log(str)


const name = 'tom'
const msg = `hey, ${name}  ${1 + 1}`
console.log(msg)

</code></pre>
<h4 id="模板字符串标签函数-tagged-templates">模板字符串标签函数 Tagged templates</h4>
<pre><code class="language-js">
const str = console.log`hello world`

const name = 'tom'
const gender = true
function myTagFunc (strings, name, gender) {
    console.log(strings, name, gender)
}
const result = myTagFunc`hey, ${name} is a ${gender}.`



const name = 'tom'
const gender = true
function myTagFunc (strings, name, gender) {
    console.log(strings, name, gender)
    return strings[0] + name + strings[1] + gender + strings[2]
}
const result = myTagFunc`hey, ${name} is a ${gender}.`
console.log(result)



</code></pre>
<h4 id="字符串的扩展方法">字符串的扩展方法</h4>
<ul>
<li>includes()</li>
<li>startsWith()</li>
<li>endsWith()</li>
</ul>
<pre><code class="language-js">const message = 'Error: foo is not defind.'

console.log(
    message.startsWith('Error'),
    message.endsWith('.'),
    message.includes('foo')
)

</code></pre>
<h2 id="4-es2015-数组和对象的解构">4. ES2015 数组和对象的解构</h2>
<h4 id="数组中的解构">数组中的解构</h4>
<pre><code class="language-js">const arr = [100, 200, 300]

const [foo, bar, baz] = arr
console.log(baz)

const [, , baz] = arr
console.log(baz)


const [foo, ...rest] = arr
console.log(rest)

const [foo] = arr
console.log(foo)

const [foo, bar, baz, more] = arr
console.log(more) // undefine


const [foo, bar, baz, more = 'default value'] = arr
console.log(more) // default value

</code></pre>
<h4 id="展开数组-spread">展开数组 Spread</h4>
<pre><code class="language-js">const arr = ['foo', 'bar', 'baz']
console.log.apply(console, arr)

console.log(...arr)

</code></pre>
<h4 id="对象的解构-destructuring">对象的解构 Destructuring</h4>
<pre><code class="language-js">const obj = { name: 'zce', age: 18}

const { name, age } = obj
console.log(name)

// 以下会出现变量名冲突，但obj解构必须 使用name 所以解决方案如下
const name = 'tom'
const { name } = obj
console.log(name)

// 解决方案
const { name: objName  } = obj
console.log(objName)


</code></pre>
<h2 id="5-es2015函数的参数">5. ES2015函数的参数</h2>
<h4 id="参数默认值-default-parameters">参数默认值 Default parameters</h4>
<pre><code class="language-js">function foo(enable) {
    enable = enable == undefine ? true : enable
    console.log('foo invaked - enable:');
    console.log(enable)
}

foo(true)


// 只能是调用的时候没有传参数或者传undefine时
function foo(enable = true) {
    console.log('foo invaked - enable:');
    console.log(enable)
}
foo(false)

// 带有默认值的形参一定要在最后
function foo(name, enable = true) {
    console.log(name, enable)
}
foo('xxx')

// 不过在浏览器环境试出结果  可以如下
function foo(name = true, enable) {
    console.log(name, enable)
}
foo(undefined, 200)

</code></pre>
<h4 id="剩余参数-rest-parameters">剩余参数 Rest parameters</h4>
<pre><code class="language-js">
console.log(1, 2, 3, 4)


funciton foo() {
    console.log(arguments)
}

// 只能出现在最后一位，只能出现一次
funciton foo(...args) {
    console.log(...args) // [1, 2, 3, 4]
}
foo(1, 2, 3, 4)



</code></pre>
<h2 id="6-箭头函数">6. 箭头函数</h2>
<h4 id="箭头函数-arrow-functions">箭头函数 Arrow functions</h4>
<blockquote>
<p>程序员专用字体 Fira Code</p>
</blockquote>
<pre><code class="language-js">
function inc(number) {
    return number + 1
}
console.log(inc(100))


const inc = n =&gt; n + 1
console.log(inc(100))

// 简化了回调函数的书写

const arr = [1,2,3]
arr.filter(function(item) {
    return item % 2
})

arr.filter(i =&gt; item % 2)
</code></pre>
<h4 id="箭头函数与this">箭头函数与this</h4>
<pre><code class="language-js">const person = {
    name: 'tom',
    sayHi: function() {
        console.log(this.name)
    }
}

person.sayHi(); // tom

const person = {
    name: 'tom',
    sayHi: () =&gt;  {
        console.log(this.name)
    }
}


person.sayHi(); // undefined

const person = {
    name: 'tom',
    sayHi: function() {
        setTimeout(function() {
            console.log(this.name)
        })
    }
}
person.sayHi(); // undefined

const person = {
    name: 'tom',
    sayHi: function() {
        setTimeout(() =&gt; {
            console.log(this.name)
        })
    }
}
person.sayHi(); // tome

</code></pre>
<h2 id="7-对象-及-字面量增强">7. 对象 及 字面量增强</h2>
<h4 id="对象及字面量增强-enhanced-object-literals">对象及字面量增强 Enhanced object literals</h4>
<pre><code class="language-js">const bar = '345'
const obj = {
    foo: 123,
    // bar: bar
    bar,
    
    // method: function() {
        
    // }
    method() {
        
    }
};

// 新增计算属性名
const obj = {
    [Math.random()]: 300
}
</code></pre>
<h4 id="对象扩展方法">对象扩展方法</h4>
<h5 id="objetassign">Objet.assign</h5>
<ul>
<li>将多个源对象中的属性复制到一个目标对象中</li>
</ul>
<pre><code class="language-js">const source1 = {
    a: 123,
    b: 123
}
const target = {
    a: 456,
    b: 456
}
const result = Object.assign(target, source1)
console.log(target)
console.log(target == result) // true

// 作用 可以用来复制一个对象


</code></pre>
<h5 id="objectis">Object.is</h5>
<pre><code class="language-js">console.log(
 0 == false,
 0 === false,
 +0 === -0,
 NaN == NaN,
 Object.is(+0, -0),
 Object.is(NaN, NaN)

)
</code></pre>
<h2 id="8-es2015-proxy">8. ES2015 Proxy</h2>
<h4 id="proxy-代理对象">Proxy 代理对象</h4>
<blockquote>
<p>Vue2.0 Object.defineProperty()</p>
</blockquote>
<pre><code class="language-js">const person = {
    name: 'zce',
    age: 20
}

const personProxy = new Proxy(person, {
    get (target, property) {
        console.log(target, property)
        return target[property]
    },
    set (target, property, value) {
        target[property] = value
    },
})

console.log(personProxy.name)
</code></pre>
<h4 id="proxy-对比-defineproperty">Proxy 对比 defineProperty</h4>
<ul>
<li>defineProperty 只能监视属性的读写</li>
<li>Proxy 能够监视到更多对象操作</li>
</ul>
<pre><code class="language-js">const person = {
    name: 'zce',
    age: 20
}

const perxonProxy = new Proxy(person, {
    deleteProperty (target, property) {
        delete target[property]
    }
})
</code></pre>
<table>
<thead>
<tr>
<th>handler方法</th>
<th>触发方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>读取某个属性</td>
</tr>
<tr>
<td>set</td>
<td>写入某个属性</td>
</tr>
<tr>
<td>has</td>
<td>in 操作符</td>
</tr>
<tr>
<td>deleteProperty</td>
<td>delete 操作符</td>
</tr>
<tr>
<td>getPrototypeOf</td>
<td>Object.getPrototypeOf()</td>
</tr>
<tr>
<td>setPrototypeOf</td>
<td>Object.setPrototypeOf()</td>
</tr>
<tr>
<td>isExtensible</td>
<td>Object.isExtensible()</td>
</tr>
<tr>
<td>preventExtensions</td>
<td>Object.perventExtensions()</td>
</tr>
<tr>
<td>getOwnPropertyDescriptor</td>
<td>Object.getOwnPropertyDescriptor()</td>
</tr>
<tr>
<td>defineProperty</td>
<td>Object.defineProperty()</td>
</tr>
<tr>
<td>ownKeys</td>
<td>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()</td>
</tr>
<tr>
<td>apply</td>
<td>调用一个函数</td>
</tr>
<tr>
<td>construct</td>
<td>用 new 调用一个函数</td>
</tr>
</tbody>
</table>
<ul>
<li>Proxy 更好的支持数组对象的监视</li>
</ul>
<blockquote>
<p>defineProperty对数组的操作是 重写数组的操作方法</p>
</blockquote>
<pre><code class="language-js">const list = []
const listProxy = new Proxy(list, {
    set (target, property, value) {
        console.log(target, property, value)
        target[property] = value;
        return true;
    }
})
</code></pre>
<ul>
<li>Proxy是以非侵入的方式监管了对象的读写</li>
</ul>
<h2 id="9-reflect-promise-class">9. Reflect、Promise、Class</h2>
<h3 id="reflect-统一的对象操作api">Reflect 统一的对象操作API</h3>
<blockquote>
<p>属于一个静态类</p>
</blockquote>
<p><s>new Reflect()</s></p>
<ul>
<li><code>Reflect</code> 内部封闭了一系列对对象的底层操作</li>
<li><code>Reflect</code> 成员方法就是 <code>Proxy</code> 处理对象的默认实现</li>
</ul>
<pre><code class="language-js">    const obj = {
        foo: '123'
    }
    // 当第二个处理对象没传时，底层默认使用Reflect上的方法
    const proxy = new Proxy(obj, {
        get (target, property) {
            return Reflect.get(target, property)
        }
    })
</code></pre>
<h5 id="推出reflect的意义">推出<code>Reflect</code>的意义</h5>
<ul>
<li>统一提供一套用于操作对象的API</li>
</ul>
<pre><code class="language-js">const obj = {
    name: 'zce',
    age: 18
}
// console.log('name' in obj)
// delete obj['age']
// Object.keys(obj)

console.log(Reflect.has(obj, 'name'))
console.log(Reflect.deleteProperty(obj, 'age'))
console.log(Reflect.ownKeys(obj))
</code></pre>
<h3 id="promise">Promise</h3>
<blockquote>
<p>解决了传统异步编程中回调函数嵌套过深的问题</p>
</blockquote>
<p>在JavaScript异步编程课程中详情分析了</p>
<h3 id="class-类">class 类</h3>
<pre><code class="language-js">function Person(name) {
    this.name = name;
}
Person.prototype.say = function() {
    console.log(`he, my name is ${this.name}`)
}

// class
class Person {
    constructor(name) {
        this.name = name;
    }
    
    say () {
        console.log(`hi, my name is ${this.name}`)
    }
}
const p = new Person('tom')
p.say()

</code></pre>
<h4 id="实例方法-vs-静态方法">实例方法 vs 静态方法</h4>
<blockquote>
<p>ES2015中新增添加静态成员的 static 关键词</p>
</blockquote>
<pre><code class="language-js">
class Person {
    constructor(name) {
        this.name = name;
    }
    
    say () {
        console.log(`hi, my name is ${this.name}`)
    }
    static create(name) {
        return new Person(name)
    }
}

const tom = Person.create('tom')
tom.say()
</code></pre>
<h4 id="类的继承-extends">类的继承 extends</h4>
<pre><code class="language-js">class Person {
    constructor(name) {
        this.name = name;
    }
    
    say () {
        console.log(`hi, my name is ${this.name}`)
    }
    static create(name) {
        return new Person(name)
    }
}

class Student {
    constructor(name, number) {
        super(name)
        this.number = number
    }
    hello() {
        super.say()
        console.log(`my school number is ${this.number}`)
    }
}
const s = new Student()
s.hello()
</code></pre>
<h2 id="10-set-map-symbol">10. Set Map Symbol</h2>
<h3 id="set-数据结构-集合">Set 数据结构 （集合）</h3>
<pre><code class="language-js">
const s = new Set()
s.add(1).add(2).add(2).add(3)

console.log(s)
s.forEacm(i =&gt; console.log(i))

for (let i of s) {
    console.log(i)
}

console.log(s.size)

console.log(s.has(100))

console.log(s.delete(3))

s.clear()

// 可以去重数组
const arr = [1,2,1,3,4,1]
const result = new Set(arr)
console.log(result)

// 如果想再得到一个数组
const result = Array.from(new Set(arr))
const result = [...new Set(arr)]


</code></pre>
<h3 id="map-数组结构">Map 数组结构</h3>
<blockquote>
<p>健值对类型，可以用任意类型的数据作为健</p>
</blockquote>
<pre><code class="language-js">
// obj key只能是字符串 或 Symbol
const obj = {}
obj[true] = 'value'
obj[123] = 'value'
obj[{a: 1}] = 'value'
console.log(Object.keys(obj))

const m = new Map()
const tom = {name: 'tom'}
m.set(tom, 90)
console.log(m)
console.log(m.get(tom))

m.has()
m.delete()
m.clear()

m.forEach((value, key) =&gt; {
    console.log(value, key)
})


</code></pre>
<h3 id="symbol">Symbol</h3>
<blockquote>
<p>表示一个独一无二的值</p>
</blockquote>
<ul>
<li>目前主要的作用就是为对象添加独一无二的属性名</li>
</ul>
<pre><code class="language-js">const cache = {}

// a.js ======
cache['foo'] = Math.random()

// b.js ======
cache['foo'] = '123'

console.log(cache)

// 表示一个独一无二的值
const s = Symbol()
console.log(Symbol() == Symbol())
console.log(Symbol('foo'))

// 对象中的key允许使用Symbol 所以有两种数据结构

const obj = {}
obj[Symbol()] = '123'
obj[Symbol()] = '456'

// a.js ===========
const name = Symbol()
const person = {
    [name]: 'zce',
    say() {
        console.log(this[name])
    }
}
person.say()
</code></pre>
<hr>
<ul>
<li>截止到ES2019，一共定义了7种数据 类型，未来会增加一个BigInt类型，目前还处在stage-4阶段，标准化就是8种数据类型</li>
</ul>
<h4 id="symbol-补充">Symbol 补充</h4>
<pre><code>// 唯一性
console.log(
    Symbol('foo') == Symbol('foo')
)
// false

const s1 = Symbol.for('foo')
const s2 = Symbol.for('foo')
s1 == s2 // true

// 不是字符串会转成字符串
console.log(
    Symbol.for(true) == Symbol.for('true')
)
// true

console.log(Symbol.iterator)
console.log(Symbol.hasInstance)

const obj = {}
console.log(obj.toString())

// 自定义
const obj = {
    [Symbol.toStringTag]: 'XObject'
}

const obj = {
    [Symbol()]: 'symbol value',
    foo: 'normal value'
}
for (var key in obj) {
    console.log(key) // foo
}
console.log(Object.keys(obj)) // ['foo']
console.log(JSON.stringify(obj)) // {foo: 'normal value'}

// 可以获取对象当中Symbol类型的key 名
console.log(Object.getOwnPropertySymbols(obj))


</code></pre>
<h1 id="11-forof-循环-迭代器-生成器-es-modules">11. for…of 循环、迭代器、生成器、ES Modules</h1>
<h3 id="forof-循环">for...of 循环</h3>
<blockquote>
<p>以后会作为遍历所有数据结构的统一方式</p>
</blockquote>
<pre><code class="language-js">const arr = [100, 200, 300, 400]

for (const item of arr) {
    console.log(item) // 拿到的是每个元素
}

// for of 可以使用关键词 break 终止循环
// arr.forEach 无法终止遍历的


const s = new Set(['foo', 'bar'])
for (const item of s) {
    console.log(item)
}

const m = new Map()
m.set('foo',l '123')
m.set('bar', '345')
// 可以改为这样
// for (const item of m) {
for (const [key, value] of m) {
    console.log(item) // ['foo', '123'] ['bar', '345'] 
}


</code></pre>
<h4 id="可迭代接口">可迭代接口</h4>
<blockquote>
<p>ES中能够表示有结构的数据类型越来越多<br>
实现Iterable接口就是 for...of的前提</p>
</blockquote>
<ul>
<li>给obj实现迭代接口 Iterable (yi te rui bo er)</li>
</ul>
<pre><code class="language-js">// 
// Symbol.iterator (yi te rui te er)
/*
const obj = {
    [Symbol.iterator]: function() {
        return {
            next: function() {
                return {
                    value: 'zce',
                    done: true
                }
            }
        }
    }
}
*/
/*
{
    value: 'zce',
    done: true
}
迭代结果接口 IterationResuklt
*/
const obj = {
    store: ['foo', 'bar', 'baz'],
    [Symbol.iterator]: function() {
        let index = 0
        const self = this
        return {
            next: function() {
                const result = {
                    value: self.store[index],
                    done: index &gt;= self.store
                }
                index++
                return result
            }
        }
    }
}
for (const item of obj) {
    console.log('循环体')
}

</code></pre>
<h4 id="迭代器模式">迭代器模式</h4>
<pre><code class="language-js">// 迭代器设计模式

// 场景： 你我协同开发一个任务清单应用

// 我的代码 =================
/*
const todos = {
    left: ['吃饭', '睡觉', '打豆豆'],
    learn: ['语文', '数学', '外语']
}

// 你的代码 =================
for (const item of todos.life) {
    console.log(item)
}
for (const item of todos.learn) {
    console.log(item)
}
*/
const todos = {
    life: ['吃饭', '睡觉', '打豆豆'],
    learn: ['语文', '数学', '外语'],
    [Symbol.iterator]: function() {
        const all = [...this.life, ...this.learn]
        let index = 0
        return {
            next: function() {
                return {
                    value: all[index],
                    done: index++ &gt;= all.length
                }
                
            }
        }
    }
}

// 你的代码 =================
for (const item of todos) {
    console.log(item)
}
</code></pre>
<h3 id="生成器-generator-jie-le-rui-te-er">生成器 Generator (jie le rui te er)</h3>
<pre><code class="language-js">
function * foo() {
    console.log('zce')
    return 100
}
const result = foo()
console.log(result.next()) 
// zce 
// { value: 100, done: true }



function *foo() {
    console.log('111')
    yield 100
    
    console.log('222')
    yield 200
}
const generator = foo()
console.log(generator.next())
console.log(generator.next())
console.log(generator.next())

</code></pre>
<h5 id="生成器应用场景">生成器应用场景</h5>
<pre><code class="language-js">// 案例1： 发号器
function * createIdMaker() {
    let id = 1
    while(true) {
        yield id++
    }
}

const idMaker = createIdMaker()

console.log(idMaker.next().value)
console.log(idMaker.next().value)
console.log(idMaker.next().value)
console.log(idMaker.next().value)


// 案例2： 使用 Generator 函数实现 iterator 方法
const todos = {
    life: ['吃饭', '睡觉', '打豆豆'],
    learn: ['语文', '数学', '外语'],
    [Symbol.iterator]: function() {
        const all = [...this.life, ...this.learn]
        for (const item of all) {
            yield item
        }
        // let index = 0
        // return {
        //     next: function() {
        //         return {
        //            value: all[index],
        //            done: index++ &gt;= all.length
        //        }
                
        //    }
        //}
    }
}

</code></pre>
<h3 id="es-modules">ES Modules</h3>
<blockquote>
<p>语言层面的模块化标准</p>
</blockquote>
<h3 id="esmascript-2016">ESMAScript 2016</h3>
<blockquote>
<p>小版本更新</p>
</blockquote>
<ul>
<li>新增<code>Array.prototype.includes</code></li>
</ul>
<pre><code class="language-js">const arr = ['foo', 1, NaN, false];
// 以前的有个问题就是不能查找到NaN
console.log(arr.indexOf(NaN))
console.log(arr.includes('foo'))
console.log(arr.includes(NaN))
</code></pre>
<ul>
<li>指数运算符</li>
</ul>
<pre><code class="language-javascript">// 以前的
console.log(Math.pow(2, 10))

// new
console.log(2 ** 10)
</code></pre>
<h3 id="esmascript-2017">ESMAScript 2017</h3>
<blockquote>
<p>小版本</p>
</blockquote>
<ul>
<li>Object.values</li>
<li>Object.entries</li>
<li>Object.getOwnPropertyDescriptors</li>
<li>String.prototype.padStart / String.prototype.padEnd</li>
<li>在函数参数中添加尾逗号</li>
<li>Async / Await</li>
</ul>
<pre><code class="language-js">const obj = {
    foo: 'value1',
    bar: 'value2'
}
// Object.values
console.log(Object.values(obj))

// Object.entries
console.log(Object.entries(obj))
for (const [key, value] of Object.entries(obj)) {
    console.log(key, value) // foo value1 | bar value2
}
// 将对象转成Map
new Map(Object.entries(obj))

// Object.getOwnPropertyDescriptors
// 获取对象当中属性的完整信息
const p1 = {
    firstName: 'Lei',
    lastName: 'wang',
    get fullName() {
        return this.firstName + ' ' + this.lastName
    }
}

const p2 = Object.assign({}, p1)
p2.firstName = 'zce'
console.log(p2.fullName)
console.log(p2) // { firstName: 'zce', lastName: 'Wang', fullMame: 'Lei Wang' }
const descriptors = Object.getOwnPropertyDescriptors(p1)
const p2 = Object.defineProperties({}, descriptors)
p2.firstName = 'zce'
console.log(p2.fullName) // zce wang

// String.prototype.padStart / String.prototype.padEnd

const books = {
    html: 5,
    css: 16,
    javascript: 128
}
for (const [name, count] of Object.entries(books)) {
    console.log(`${name.padEnd(16, '-')} | ${count.toString().padStart(3, '0')}`)
}
/*
html------------ | 005
css------------- | 016
javascript------ | 128
*/

// 在函数参数中添加尾逗号
const arr = [
    100,
    200,
    300,
]


</code></pre>
<h4 id="async-await">Async / Await</h4>
<blockquote>
<p>使用Promise的语法糖</p>
</blockquote>

                </div>
            </article>
        </main>
    </div>
    <div class="doc-footer-nav mdui-color-theme">
        <div class="mdui-container">
            <div class="mdui-row">
                
                <a href="https://hongchengfhc.github.io/jin-jie-1-02-02ts-jie-shao-ji-js-lei-xing-jian-cha/" class="mdui-ripple mdui-color-theme mdui-col-xs-2 mdui-col-sm-6 doc-footer-nav-left">
                    <div class="doc-footer-nav-text">
                        <i class="mdui-icon material-icons">arrow_back</i>
                        <span class="doc-footer-nav-direction mdui-hidden-xs-down">上一篇文章</span>
                        <div class="doc-footer-nav-chapter mdui-hidden-xs-down">进阶1-02-02TS介绍及JS类型检查</div>
                    </div>
                </a>
                
                
                <a href="https://hongchengfhc.github.io/jin-jie-1-01-03-shou-xie-promise/" class="mdui-ripple mdui-color-theme mdui-col-xs-10 mdui-col-sm-6 doc-footer-nav-right">
                    <div class="doc-footer-nav-text">
                        <i class="mdui-icon material-icons">arrow_forward</i>
                        <span class="doc-footer-nav-direction">下一篇文章</span>
                        <div class="doc-footer-nav-chapter">进阶1-01-03手写Promise</div>
                    </div>
                </a>
                
            </div>
        </div>
    </div>
    <br>
    
    <div class="comment"></div>
</div>
<footer class="mdui-container footer ">
    <div class="head_card-offset"></div>
    <div class="mdui-row mdui-row-gapless">
        <div class="k-container">
            <img width="100%" src="/media/img/skirt.png">
        </div>
    </div>

    <div class="site-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
</footer>
<div id="landlord" style="left:5px;bottom:0px;">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
            <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off" placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
            <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off" placeholder="要和我聊什么呀？"/>
            <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        <div class="live_ico_item type_music" id="musicButton"></div>
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input id="duType" value="douqilai,l2d_caihong" type="hidden">
    </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>
<script>
    var message_Path = '/media/live2d/';//资源目录，如果目录不对请更改
    var talkAPI = "";//如果有类似图灵机器人的聊天接口请填写接口路径
</script>
<!--<script src="/media/js/jquery-3.3.1.min.js"></script>-->
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/media/live2d/js/message.js"></script>

</body>
<script src="//cdnjs.loli.net/ajax/libs/mdui/0.4.3/js/mdui.min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    $('.comment').bind('DOMNodeInserted',()=>{
        $('.comment').unbind()

        $('.vbtn').addClass(' mdui-btn mdui-color-theme-accent mdui-ripple')
    })

    let valine = new Valine({
        el: '.comment',
        
        
        
        path: window.location.pathname,
        pageSize: 30,
        avatar:'mm',
        notify:true
    })
</script>
</html>
