<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进阶1-02-02TS介绍及JS类型检查 | Gridea</title>
<link rel="shortcut icon" href="https://hongchengfhc.github.io//favicon.ico?v=1616737758970">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://hongchengfhc.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="进阶1-02-02TS介绍及JS类型检查 | Gridea - Atom Feed" href="https://hongchengfhc.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
TypeScript 大大提高代码的可靠程度
JavaScript 自有类型系统的问题

介绍TypeScript前先介绍一下类型检查
介绍模块

强类型与弱类型
静态类型与动态类型
JavaScript 自有类型系统的问题
Flow静态..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://hongchengfhc.github.io/">
  <img class="avatar" src="https://hongchengfhc.github.io//images/avatar.png?v=1616737758970" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              进阶1-02-02TS介绍及JS类型检查
            </h2>
            <div class="post-info">
              <span>
                2021-03-26
              </span>
              <span>
                13 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <ol>
<li><code>TypeScript</code> 大大提高代码的可靠程度</li>
<li><code>JavaScript</code> 自有类型系统的问题</li>
</ol>
<h1 id="介绍typescript前先介绍一下类型检查">介绍TypeScript前先介绍一下类型检查</h1>
<h4 id="介绍模块">介绍模块</h4>
<ol>
<li>强类型与弱类型</li>
<li>静态类型与动态类型</li>
<li><code>JavaScript</code> 自有类型系统的问题</li>
<li><code>Flow</code>静态类型检查方案</li>
<li><code>TypeScript</code>语言规范与基本应用</li>
</ol>
<h2 id="1-类型介绍">1. 类型介绍</h2>
<h3 id="1-强类型-vs-弱类型">1. 强类型 vs 弱类型</h3>
<ol>
<li>强类型:  语言层面限制函数的实参类型必须与形参类型相同</li>
</ol>
<p>eg:</p>
<pre><code class="language-java">class Main {
    static void foo(int num) {
        System.out.println(num);
    }
    
    public static void main(String[] args) {
        Main.foo(100); // ok
        
        Main.foo(&quot;100&quot;); // error &quot;100&quot; is a string
        
        Main.foo(Integer.parseInt(&quot;100 &quot;)); // ok
    }
}
</code></pre>
<ol start="2">
<li>弱类型：语言层面不会限制实参的类型<br>
eg</li>
</ol>
<pre><code class="language-js">function foo(num) {
    console.log(num)
}
foo(100) // ok
foo('100') // ok
foo(parseInt('100')) // ok
</code></pre>
<blockquote>
<p>由于这种强弱类型之分根本不是某个权威机构的定义;</p>
</blockquote>
<blockquote>
<p>强类型有更强的类型约束，而弱类型中几乎没有什么约束</p>
</blockquote>
<h5 id="个人理解">个人理解:</h5>
<ol>
<li>强类型语言中不允许什么问题的隐式类型转换</li>
<li>弱类型语言则允许任意的数据隐式类型转换</li>
<li>强类型不允许随意的隐式类型转换，而弱类型是允许的</li>
<li>变量类型允许随时改变的特点，不是强毕竟类型的差异</li>
</ol>
<h3 id="2-类型系统">2. 类型系统</h3>
<blockquote>
<p>静态类型与动态类型</p>
</blockquote>
<ol>
<li>静态类型: 一个变量声明时它的类型就是明确的,声明过后，它的类型就不允许修改了</li>
<li>动态类型：在运行阶段才能够明确变量类型，而且变量的类型随时可以改变<br>
eg:</li>
</ol>
<pre><code class="language-js">var foo = 100
foo = 'bar' // ok
console.log(foo)
</code></pre>
<p><strong>也可以说在动态类型语文中的变量没有类型，而变量中存放的值是有类型的</strong></p>
<h4 id="类型安全分为-强类型-和-弱类型">类型安全分为 <code>强类型</code> 和 <code>弱类型</code></h4>
<h4 id="类型检查分为-静态类型-和-动态类型">类型检查分为 <code>静态类型</code> 和 <code>动态类型</code></h4>
<p>如下图<br>
<a href="https://imgtu.com/i/6fUjc4"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac1925adb7414225aca91db0345d7e7f~tplv-k3u1fbpfcp-zoom-1.image" alt="6fUjc4.png" loading="lazy"></a></p>
<h4 id="21-javascript-类型系统特征">2.1 JavaScript 类型系统特征</h4>
<blockquote>
<p><code>弱类型</code> 且 <code>动态类型</code></p>
</blockquote>
<p><font color="red"><strong>js的类型用一个词描述：【<code>任性</code>】</strong></font> 缺失了类型系统的可靠性 --&gt; <font color="red"><code>不靠谱</code></font></p>
<h5 id="为什么javascript不是强类型-静态类型">? 为什么JavaScript不是强类型 / 静态类型</h5>
<pre><code>1. 早前的 JavaScript 应用简单
2. JavaScript 没有编译环节
3. 选择为 弱类型 / 动态类型
4. 在大规模应用下，这种【优势】就变成了短板
</code></pre>
<h4 id="弱类型的问题">弱类型的问题</h4>
<blockquote>
<p>举例</p>
</blockquote>
<pre><code class="language-js">// 01
const obj = {}
obj.foo()
// 报错要等到运行阶段才能发现类型异常
// ======================
// 02
function sum(a, b) {
    return a + b
}
console.log(sum(100, 100)) // 200
console.log(sum(100, '100')) // 100100
// ======================
// 03
const obj = {}
obj[true] = 100 // 会自动转换成字符串

console.log(obj['true'])
</code></pre>
<h4 id="强类型的优势">强类型的优势</h4>
<ol>
<li>错误更早暴露</li>
<li>代码更智能，编码更准确</li>
<li>重构更牢靠</li>
<li>减少不必要的类型判断</li>
<li>......</li>
</ol>
<h2 id="2-flow-js的类型检查工具">2. Flow js的类型检查工具</h2>
<h4 id="flow">Flow</h4>
<blockquote>
<p>JavaScript的类型的检查器</p>
</blockquote>
<p><strong>Flow只是一个小工具，So Easy</strong></p>
<pre><code class="language-js">// 类型注解
function sum (a: number, b: number) {
    return a + b
}
sum(100, 50) // ok
sum('100', 50) // error
</code></pre>
<h4 id="快速上手">快速上手</h4>
<pre><code class="language-js">// 安装 yarn add flow-bin --dev

// 增加.flowconfig文件 yarn flow init
/*
.flowconfig
[ignore]
[include]
[libs]
[lints]
[options]
[strict]
*/

// 使用的时候需要在文件顶上增加 @flow，并且需要关闭掉vscode的语法校验
// @flow
function sum (a, b) {
    return a + b
}

// 终端使用命令检查 
// 执行 yarn flow
// 停止 yarn flow stop
</code></pre>
<h4 id="编译">编译</h4>
<ul>
<li>写好的js文件没办法用node执</li>
</ul>
<pre><code class="language-js">// 所以安装 yarn add flow-remove-types --dev

// 执行 yarn flow-remove-types [文件目录] . -d [输出目录]

</code></pre>
<h5 id="尝试使用babel">尝试使用babel</h5>
<pre><code>// @babel/core 核心模块
// @babel/cli cli工具，可以让我们在命令行中直接使用babel命令去完成编译
// @babel/preset-flow --dev
// 安装
// yarn add @babel/core @babel/cli @babel/preset-flow --dev

// 2. 添加babel的配置文件 .babelrc
/*
// .babelrc
{
    &quot;presets&quot;: [&quot;@babel/preset-flow&quot;]
}

*/
// 执行命令 yarn babel src -d dist

</code></pre>
<h4 id="开发工具插件-flow-lanugage-support">开发工具插件 Flow Lanugage Support</h4>
<blockquote>
<p>让错误直接在开发工具上显示出来</p>
</blockquote>
<ul>
<li>下载插件 Flow Lanugage Support</li>
</ul>
<h4 id="类型推断-type-inference">类型推断 Type Inference</h4>
<pre><code class="language-js">/**
* 类型推断
* @flow
*/
function square (n) {
    return n * n
}
square('100') // 这里用了字符串,flow会推导出 n*n是错误的
</code></pre>
<h4 id="类型注解-type-annotations">类型注解 Type Annotations</h4>
<pre><code>// 1. 函数的参数上以及返参
funcion square(n:  number): number {
    return n * n
}
// 2. 变量
let num: number = 100;

// 3. 没有返回值标记成void
function say(): void {}
</code></pre>
<h4 id="原始类型-primitive-types">原始类型 Primitive Types</h4>
<pre><code class="language-js">let a: string = 'foobar'

let b: number = Infinity // NaN // 100

let c: boolean = true

let d: null = null

let e: void = undefined

let f: symbol = Symbol()
</code></pre>
<h4 id="数组类型-array-types">数组类型 Array Types</h4>
<pre><code class="language-js">// 泛型
const arr1: Array&lt;number&gt; = [1, 2, 3]

const arr2: number[] = [1, 2, 3]

// 元组
const f00: [string, number] = ['foo', 100]
</code></pre>
<h4 id="对象类型-object-types">对象类型 Object Types</h4>
<pre><code class="language-js">const obj1: {foo: string, bar: number} = { foo: 'string', bar: 100 }

const obj2: {foo?: string, bar: number} = {bar: 100}  // foo可选

const obj3: {[string]: string} = {}
obj3.key1 = 'value1'
obj3.key2 = 'value2'
</code></pre>
<h4 id="函数类型-function-types">函数类型 Function Types</h4>
<pre><code class="language-js">
function foo(callback: (string, number) =&gt; void) {
    callback('string', 100)
}

foo(function(str, n) {
    // str =&gt; string
    // n =&gt; number
})
</code></pre>
<h4 id="特殊类型">特殊类型</h4>
<pre><code class="language-js">
// 字面量类型
const a: 'foo' = 'foo' // a变量只能为 foo字符串

const type: 'success' | 'warning' | 'danger' = 'success'

const b: string | number = 100 // 'string'

type StringOrNumber = string | number

const c: StringOrNumber = 'string' // 100

// maybe 类型
const gender: ?number = null // undefined // number
// 上面等价于下面这个
const gender: number | null | void = undefined // null // number

</code></pre>
<h4 id="mixed-any-任意类型">Mixed &amp; Any 任意类型</h4>
<pre><code class="language-js">// mixed 就是所有类型 ==&gt; string | number | boolean | ....
function passMixed(value: mixed) {
    
}
passMixed('string')
passMixed(100)

// -----------------------

function passAny(value: any) {
    
}
passAny('string')
passAny(100)

// 区别是  any是弱类型  mixed是强类型
function passMixed(value: mixed) {
    value.substr(1)
    value * value
    // 这里会提示报错
    // 改成下面
    if (typeof value == 'value') {
        value.substr(1)
    }
    if (typeof value == 'number') {
        value * value
    }
}
passMixed('string')
passMixed(100)

// -----------------------

function passAny(value: any) {
    value.substr(1)
    value * value
}
passAny('string')
passAny(100)

</code></pre>
<h3 id="类型小结">类型小结</h3>
<ul>
<li>官方文档 https://flow.org/en/docs/types/</li>
<li>第三方类型手册 https://www.saltycrane.com/cheat-sheets/flow-type/latest/</li>
</ul>
<h4 id="运行环境api-内置对象">运行环境API -&gt; 内置对象</h4>
<pre><code class="language-js">const element: HTMLElement | null = document.getElementById('app') // 这里必须传字符串 传数字会提示报错

// https://github.com/facebook/flow/blob/master/lib/core.js
// https://github.com/facebook/flow/blob/master/lib/dom.js
// https://github.com/facebook/flow/blob/master/lib/bom.js
// https://github.com/facebook/flow/blob/master/lib/cssom.js
// https://github.com/facebook/flow/blob/master/lib/node.js

</code></pre>
<h2 id="3-typescript">3. TypeScript</h2>
<h3 id="typescript-javascript的超集-superset">TypeScript JavaScript的超集 (superset)</h3>
<blockquote>
<p>任何一种JavaScript运行环境都支持</p>
</blockquote>
<ul>
<li>功能更为强大，生态也更健全、更完善</li>
<li>开源框架使用ts Angular / Vue.js3.0</li>
<li>TypeScript -- 前端领域中的第二语言</li>
</ul>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/6h2r1s"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e031654f7294489a96eb58c458182d75~tplv-k3u1fbpfcp-zoom-1.image" alt="6h2r1s.png" loading="lazy"></a></figure>
<p>TypeScript属于渐进式</p>
<h4 id="缺点">缺点</h4>
<ol>
<li>语言本身多了很多概念</li>
<li>项目初期，TypeScript会增加一些成本</li>
</ol>
<hr>
<h3 id="快速上手-2">快速上手</h3>
<pre><code class="language-shell">yarn init --yes

yarn add typescript --dev

yarn tsc xxxx.ts

</code></pre>
<pre><code>// 可以完全按照 JavaScript 标准语法编写代码
</code></pre>
<h4 id="配置文件">配置文件</h4>
<blockquote>
<p>yarn tsc --init 生成一个tsconfig.json</p>
</blockquote>
<pre><code class="language-js">compilerOptions
    target: 编译之后的ES版本
    module: 输出的代码采用什么样的方式进行模块化
    lib: 指定所引用的标准库 [&quot;ES2015&quot;, &quot;DOM&quot;]
    outDir: 设置编译结果输出到的文件夹 dist
    rootDir: 配置我们源代码的文件夹 src
    sourceMap: 是否开启源代码映射
    strice: 是否开启严格模式
需要直接运行tsc命令编译整个项目
yarn tsc
</code></pre>
<h4 id="原始类型-primitive-types-2">原始类型 Primitive Types</h4>
<pre><code>const a: string = 'foobar'

const b: number = 100 // NaN Infinity

const c: boolean = true // false
// 以上是在非严格模式下均可设置为 null

const e: void = undefined

const f: null = null

const g: undefined = undefined

const h: symbol = Symbol()
</code></pre>
<h4 id="标准库声明">标准库声明</h4>
<blockquote>
<p>就是内置对象所对应的声明</p>
</blockquote>
<h4 id="中文错误信息">中文错误信息</h4>
<pre><code>const error: string = 100
</code></pre>
<h4 id="作用域问题">作用域问题</h4>
<blockquote>
<p>两个.ts文件使用相同变量量会提示错误</p>
</blockquote>
<ul>
<li>解决就是用单独的作用域，可以使用 <code>export {}</code></li>
</ul>
<h4 id="object-类型-object-types">Object 类型 Object Types</h4>
<blockquote>
<p>不单指对象</p>
</blockquote>
<pre><code class="language-ts">const foo: object = {} // [] // function() {}

// 可以这样定义指定为对象 可以用接口
const obj = {foo: number } = { foo: 123 }
</code></pre>
<h4 id="数组类型-array-types-2">数组类型 Array Types</h4>
<pre><code class="language-js">const arr1: Array&lt;number&gt; = [1, 2, 3]
const arr2: number[] = [1, 2, 3]

// -------------------------

function sum(...args: number[]) {
    return args.reduce((prev, current) =&gt; prev + current, 0)
}
sum(1, 2, 3)

</code></pre>
<h4 id="元组类型-tuple-types">元组类型 Tuple Types</h4>
<blockquote>
<p>明确元素数量以及每个元素类型的一个数组，类型不必要完全相同</p>
</blockquote>
<pre><code class="language-js">const tuple:  [number, string] = [18, 'string']

tuple[0]
tuple[1]

const [age, name] = tuple

// ------------------------

</code></pre>
<h4 id="枚举类型-enum-types">枚举类型 Enum Types</h4>
<ol>
<li>给一组数值去分别取上更好理解的名字</li>
<li>一个枚举中只会存在几个固定的值，并不会出现超出范围的可能性</li>
</ol>
<pre><code class="language-js">enum OrderStatus {
    WaitPay = 0,
    Pay = 1,
    Cancel = 2
}

// 枚举的值可以是字符串
enum OrderStatus {
    WaitPay = 'waitPay',
    Pay = 'pay'
}
// 会被编译成以下代码
var OrderStatus;
(function (OrderStatus) {
    OrderStatus[&quot;WaitPay&quot;] = &quot;waitpay&quot;;
    OrderStatus[&quot;Pay&quot;] = &quot;pay&quot;;
})(OrderStatus || (OrderStatus = {}));

// 如果枚举的值是数值的，可以这样取 OrderStatus[0]

// 在enum 的前面加上 const
const enum OrderStatus {
    WaitPay = 0,
    Pay
}
// 编译的时候会去掉枚举相关的信息，只留下 0 , 1 , 3
</code></pre>
<h4 id="函数类型-function-types-2">函数类型 Function Types</h4>
<blockquote>
<p>输入输出类型限制</p>
</blockquote>
<pre><code class="language-js">function func1(a: number, b: number): string {
    return 'func1'
}
// 可选参数 可以设置 a?: number

// -------------------------
// 函数的表示式
const func2: (a: number, b: number) =&gt; string = function(a: number, b: number): string {
    return 'func2'
}
</code></pre>
<h4 id="任意类型-any-types">任意类型 Any Types</h4>
<blockquote>
<p>不会有任何的类型检查</p>
</blockquote>
<pre><code class="language-js">function stringify(value: any) {
    return JSON.stringify(value)
}
</code></pre>
<h4 id="隐式类型推断-type-inference">隐式类型推断 Type Inference</h4>
<blockquote>
<p>建议为每个变量添加明确的类型</p>
</blockquote>
<pre><code class="language-js">let age = 18 // 推断为age: number

age = 'string' // 会报错

let foo; // 推断为any
foo = 100
foo = 'string'
// 都是可以的

</code></pre>
<h4 id="类型断言-type-assertions">类型断言 Type assertions</h4>
<blockquote></blockquote>
<pre><code class="language-js">// 假定这个 nums 来自一个明确的接口
const nums = [110, 120, 119, 112]

const res = nums.find(i =&gt; i &gt; 0) // 推导出res 为 number | undefined

// 我们需要告诉Ts,这就是一个number类型
const num1 = res as number
const num1 = &lt;number&gt;res  // JSX 下不能使用
</code></pre>
<h4 id="接口-interfaces">接口 Interfaces</h4>
<blockquote>
<p>一种规范，约定</p>
</blockquote>
<pre><code class="language-js">
interface IPost {
    title: string;
    content: string
}

function printPost(post: IPost) {
    console.log(post.title)
    console.log(post.content)
}
</code></pre>
<ul>
<li>可选成员、只读成员</li>
</ul>
<pre><code class="language-js">interface IPost {
    title: string;
    content: string;
    subtitle?: string // 可选参数  string | undefined
    readonly summary: string // 不允许修改
}

// 动态成员
interface Cache {
    [prop: string]: string
}
</code></pre>
<h4 id="类">类</h4>
<blockquote>
<p>用来描述一类具体对象的抽象成员</p>
</blockquote>
<ol>
<li>ES6以前， 函数 + 原型 模拟实现类</li>
<li>ES6开始 JavaScript中有了专门的class</li>
<li>TypeScript 增强了class 的相关语法</li>
</ol>
<h5 id="1-基本使用">1. 基本使用</h5>
<pre><code class="language-ts">class Person {

    name: string;
    age: number;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    sayHi(msg: string) {
        console.log(`I am ${this.name} , ${msg}`)
    }
}
</code></pre>
<h5 id="2-访问修饰符">2. 访问修饰符</h5>
<ol>
<li>private 私有属性，只能在内部用this访问</li>
<li>public public 公有成员</li>
<li>protected 受保护的  不能在外部访问</li>
</ol>
<p><strong>protected在子类中使用this是可以访问到的</strong></p>
<h5 id="3-只读属性">3. 只读属性</h5>
<blockquote>
<p>在访问修饰符后面加上 readonly</p>
</blockquote>
<pre><code class="language-js">// 比如
public readonly name: string;
</code></pre>
<h5 id="4-类与接口">4. 类与接口</h5>
<pre><code>// 规定协议 

interface Eat {
    eat(food: string): void
}

interface Run {
    run(distance: number): void
}

class Person implements Eat, Run {
    eat(food: string): void {

    }
    run(distance: number): void {

    }
}

class Animal implements Eat, Run {
    eat(food: string): void {

    }
    run(distance: number): void {

    }
}
</code></pre>
<h5 id="5-抽象类">5. 抽象类</h5>
<blockquote>
<p>抽象类使用 关键字 abstract</p>
</blockquote>
<pre><code class="language-js">export {} // 确保跟其它示例没有成员冲突
abstract class Animal {
    eat(food: string): void {
        console.log('呼噜呼噜的吃' + food)
    }
    // 定义抽象方法
    abstract run (distance: number): void
}

class Dog extends Animal {
    run(distance: number): void {
        console.log('四脚爬行', distance)
    }
}
const d = new Dog()
</code></pre>
<h5 id="6-泛型-generics">6. 泛型 Generics</h5>
<blockquote>
<p>定义函数或接口、类的时候没有指定具体的类型，等到我们使用的时候再去指定具体类型的特征</p>
</blockquote>
<pre><code class="language-typescript">function createArray&lt;T&gt;(length: number, value: T): T[] {
    const arr = Array&lt;T&gt;(length).fill(value)
    return arr
}
const res = createArray&lt;string&gt;(3, 'foo')

</code></pre>
<h5 id="7-类型声明-type-declaration">7. 类型声明 Type Declaration</h5>
<blockquote>
<p>为了兼容普通的js模块</p>
</blockquote>
<pre><code class="language-typescript">import { camelCase } from 'lodash'

declare function camelCase (input: string): string
const res = camelCase('hello typed') // 在这里函数没有提示，需要声明 如上

</code></pre>
<p><strong>引用第三方模块，如果模块中不包含类型声明文件，就需要自己声明</strong></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%BB%8B%E7%BB%8Dtypescript%E5%89%8D%E5%85%88%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">介绍TypeScript前先介绍一下类型检查</a><br>
*<br>
*<br>
* <a href="#%E4%BB%8B%E7%BB%8D%E6%A8%A1%E5%9D%97">介绍模块</a>
<ul>
<li><a href="#1-%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D">1. 类型介绍</a>
<ul>
<li><a href="#1-%E5%BC%BA%E7%B1%BB%E5%9E%8B-vs-%E5%BC%B1%E7%B1%BB%E5%9E%8B">1. 强类型 vs 弱类型</a><br>
*
<ul>
<li><a href="#%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3">个人理解:</a></li>
</ul>
</li>
<li><a href="#2-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">2. 类型系统</a>
<ul>
<li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E5%88%86%E4%B8%BA-%E5%BC%BA%E7%B1%BB%E5%9E%8B-%E5%92%8C-%E5%BC%B1%E7%B1%BB%E5%9E%8B">类型安全分为 <code>强类型</code> 和 <code>弱类型</code></a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%88%86%E4%B8%BA-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B-%E5%92%8C-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B">类型检查分为 <code>静态类型</code> 和 <code>动态类型</code></a></li>
<li><a href="#21-javascript-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%89%B9%E5%BE%81">2.1 JavaScript 类型系统特征</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88javascript%E4%B8%8D%E6%98%AF%E5%BC%BA%E7%B1%BB%E5%9E%8B-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B">? 为什么JavaScript不是强类型 / 静态类型</a></li>
</ul>
</li>
<li><a href="#%E5%BC%B1%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98">弱类型的问题</a></li>
<li><a href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8A%BF">强类型的优势</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-flow-js%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7">2. Flow js的类型检查工具</a><br>
*
<ul>
<li><a href="#flow">Flow</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B">快速上手</a></li>
<li><a href="#%E7%BC%96%E8%AF%91">编译</a>
<ul>
<li><a href="#%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8babel">尝试使用babel</a></li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6-flow-lanugage-support">开发工具插件 Flow Lanugage Support</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-type-inference">类型推断 Type Inference</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3-type-annotations">类型注解 Type Annotations</a></li>
<li><a href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B-primitive-types">原始类型 Primitive Types</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B-array-types">数组类型 Array Types</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-object-types">对象类型 Object Types</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-function-types">函数类型 Function Types</a></li>
<li><a href="#%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B">特殊类型</a></li>
<li><a href="#mixed-any-%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B">Mixed &amp; Any 任意类型</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%BB%93">类型小结</a>
<ul>
<li><a href="#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83api-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1">运行环境API -&gt; 内置对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-typescript">3. TypeScript</a>
<ul>
<li><a href="#typescript-javascript%E7%9A%84%E8%B6%85%E9%9B%86-superset">TypeScript JavaScript的超集 (superset)</a>
<ul>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点</a></li>
</ul>
</li>
<li><a href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-2">快速上手</a>
<ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B-primitive-types-2">原始类型 Primitive Types</a></li>
<li><a href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%A3%B0%E6%98%8E">标准库声明</a></li>
<li><a href="#%E4%B8%AD%E6%96%87%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF">中文错误信息</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98">作用域问题</a></li>
<li><a href="#object-%E7%B1%BB%E5%9E%8B-object-types">Object 类型 Object Types</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B-array-types-2">数组类型 Array Types</a></li>
<li><a href="#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B-tuple-types">元组类型 Tuple Types</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-enum-types">枚举类型 Enum Types</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-function-types-2">函数类型 Function Types</a></li>
<li><a href="#%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B-any-types">任意类型 Any Types</a></li>
<li><a href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-type-inference">隐式类型推断 Type Inference</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-type-assertions">类型断言 Type assertions</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3-interfaces">接口 Interfaces</a></li>
<li><a href="#%E7%B1%BB">类</a>
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">1. 基本使用</a></li>
<li><a href="#2-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">2. 访问修饰符</a></li>
<li><a href="#3-%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7">3. 只读属性</a></li>
<li><a href="#4-%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3">4. 类与接口</a></li>
<li><a href="#5-%E6%8A%BD%E8%B1%A1%E7%B1%BB">5. 抽象类</a></li>
<li><a href="#6-%E6%B3%9B%E5%9E%8B-generics">6. 泛型 Generics</a></li>
<li><a href="#7-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E-type-declaration">7. 类型声明 Type Declaration</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://hongchengfhc.github.io/jin-jie-1-02-01-esmascript-xin-te-xing/">
              <h3 class="post-title">
                进阶1-02-01 ESMAScript 新特性
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://hongchengfhc.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
